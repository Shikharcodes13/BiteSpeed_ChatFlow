{"ast":null,"code":"// Flow validation utility functions\n/**\r\n * Validates the flow before saving\r\n * @param {Array} nodes - Array of nodes in the flow\r\n * @param {Array} edges - Array of edges in the flow\r\n * @returns {Object} - Validation result with isValid boolean and error message\r\n */export const validateFlow=(nodes,edges)=>{// If there are no nodes, the flow is valid (empty flow)\nif(nodes.length===0){return{isValid:true,error:''};}// If there's only one node, the flow is valid\nif(nodes.length===1){return{isValid:true,error:''};}// Check for nodes with empty target handles\nconst nodesWithEmptyTargetHandles=getNodesWithEmptyTargetHandles(nodes,edges);// Validation rule: If there are more than one nodes and more than one node has empty target handles\nif(nodes.length>1&&nodesWithEmptyTargetHandles.length>1){return{isValid:false,error:'Cannot save Flow: More than one node has empty target handles. Please connect all nodes properly.'};}// Additional validation: Check for disconnected nodes (nodes with no connections at all)\nconst disconnectedNodes=getDisconnectedNodes(nodes,edges);if(disconnectedNodes.length>0){return{isValid:false,error:\"Cannot save Flow: Found \".concat(disconnectedNodes.length,\" disconnected node(s). Please connect all nodes to create a valid flow.\")};}return{isValid:true,error:''};};/**\r\n * Gets nodes that have empty target handles (no incoming edges)\r\n * @param {Array} nodes - Array of nodes in the flow\r\n * @param {Array} edges - Array of edges in the flow\r\n * @returns {Array} - Array of node IDs with empty target handles\r\n */const getNodesWithEmptyTargetHandles=(nodes,edges)=>{const nodesWithTargetHandles=nodes.filter(node=>{// Check if this node has any incoming edges (target handles)\nconst hasIncomingEdges=edges.some(edge=>edge.target===node.id);return!hasIncomingEdges;});return nodesWithTargetHandles.map(node=>node.id);};/**\r\n * Gets nodes that are completely disconnected (no incoming or outgoing edges)\r\n * @param {Array} nodes - Array of nodes in the flow\r\n * @param {Array} edges - Array of edges in the flow\r\n * @returns {Array} - Array of node IDs that are disconnected\r\n */const getDisconnectedNodes=(nodes,edges)=>{return nodes.filter(node=>{// Check if this node has any connections (incoming or outgoing)\nconst hasIncomingEdges=edges.some(edge=>edge.target===node.id);const hasOutgoingEdges=edges.some(edge=>edge.source===node.id);return!hasIncomingEdges&&!hasOutgoingEdges;}).map(node=>node.id);};/**\r\n * Gets the flow statistics for debugging purposes\r\n * @param {Array} nodes - Array of nodes in the flow\r\n * @param {Array} edges - Array of edges in the flow\r\n * @returns {Object} - Flow statistics\r\n */export const getFlowStats=(nodes,edges)=>{const nodesWithEmptyTargetHandles=getNodesWithEmptyTargetHandles(nodes,edges);const disconnectedNodes=getDisconnectedNodes(nodes,edges);return{totalNodes:nodes.length,totalEdges:edges.length,nodesWithEmptyTargetHandles:nodesWithEmptyTargetHandles.length,disconnectedNodes:disconnectedNodes.length,nodeTypes:nodes.reduce((acc,node)=>{acc[node.type]=(acc[node.type]||0)+1;return acc;},{})};};","map":{"version":3,"names":["validateFlow","nodes","edges","length","isValid","error","nodesWithEmptyTargetHandles","getNodesWithEmptyTargetHandles","disconnectedNodes","getDisconnectedNodes","concat","nodesWithTargetHandles","filter","node","hasIncomingEdges","some","edge","target","id","map","hasOutgoingEdges","source","getFlowStats","totalNodes","totalEdges","nodeTypes","reduce","acc","type"],"sources":["C:/Users/hp/BiteSpeed/src/utils/flowValidation.js"],"sourcesContent":["// Flow validation utility functions\r\n\r\n/**\r\n * Validates the flow before saving\r\n * @param {Array} nodes - Array of nodes in the flow\r\n * @param {Array} edges - Array of edges in the flow\r\n * @returns {Object} - Validation result with isValid boolean and error message\r\n */\r\nexport const validateFlow = (nodes, edges) => {\r\n  // If there are no nodes, the flow is valid (empty flow)\r\n  if (nodes.length === 0) {\r\n    return { isValid: true, error: '' };\r\n  }\r\n\r\n  // If there's only one node, the flow is valid\r\n  if (nodes.length === 1) {\r\n    return { isValid: true, error: '' };\r\n  }\r\n\r\n  // Check for nodes with empty target handles\r\n  const nodesWithEmptyTargetHandles = getNodesWithEmptyTargetHandles(nodes, edges);\r\n\r\n  // Validation rule: If there are more than one nodes and more than one node has empty target handles\r\n  if (nodes.length > 1 && nodesWithEmptyTargetHandles.length > 1) {\r\n    return {\r\n      isValid: false,\r\n      error: 'Cannot save Flow: More than one node has empty target handles. Please connect all nodes properly.'\r\n    };\r\n  }\r\n\r\n  // Additional validation: Check for disconnected nodes (nodes with no connections at all)\r\n  const disconnectedNodes = getDisconnectedNodes(nodes, edges);\r\n  if (disconnectedNodes.length > 0) {\r\n    return {\r\n      isValid: false,\r\n      error: `Cannot save Flow: Found ${disconnectedNodes.length} disconnected node(s). Please connect all nodes to create a valid flow.`\r\n    };\r\n  }\r\n\r\n  return { isValid: true, error: '' };\r\n};\r\n\r\n/**\r\n * Gets nodes that have empty target handles (no incoming edges)\r\n * @param {Array} nodes - Array of nodes in the flow\r\n * @param {Array} edges - Array of edges in the flow\r\n * @returns {Array} - Array of node IDs with empty target handles\r\n */\r\nconst getNodesWithEmptyTargetHandles = (nodes, edges) => {\r\n  const nodesWithTargetHandles = nodes.filter(node => {\r\n    // Check if this node has any incoming edges (target handles)\r\n    const hasIncomingEdges = edges.some(edge => edge.target === node.id);\r\n    return !hasIncomingEdges;\r\n  });\r\n\r\n  return nodesWithTargetHandles.map(node => node.id);\r\n};\r\n\r\n/**\r\n * Gets nodes that are completely disconnected (no incoming or outgoing edges)\r\n * @param {Array} nodes - Array of nodes in the flow\r\n * @param {Array} edges - Array of edges in the flow\r\n * @returns {Array} - Array of node IDs that are disconnected\r\n */\r\nconst getDisconnectedNodes = (nodes, edges) => {\r\n  return nodes.filter(node => {\r\n    // Check if this node has any connections (incoming or outgoing)\r\n    const hasIncomingEdges = edges.some(edge => edge.target === node.id);\r\n    const hasOutgoingEdges = edges.some(edge => edge.source === node.id);\r\n    \r\n    return !hasIncomingEdges && !hasOutgoingEdges;\r\n  }).map(node => node.id);\r\n};\r\n\r\n/**\r\n * Gets the flow statistics for debugging purposes\r\n * @param {Array} nodes - Array of nodes in the flow\r\n * @param {Array} edges - Array of edges in the flow\r\n * @returns {Object} - Flow statistics\r\n */\r\nexport const getFlowStats = (nodes, edges) => {\r\n  const nodesWithEmptyTargetHandles = getNodesWithEmptyTargetHandles(nodes, edges);\r\n  const disconnectedNodes = getDisconnectedNodes(nodes, edges);\r\n\r\n  return {\r\n    totalNodes: nodes.length,\r\n    totalEdges: edges.length,\r\n    nodesWithEmptyTargetHandles: nodesWithEmptyTargetHandles.length,\r\n    disconnectedNodes: disconnectedNodes.length,\r\n    nodeTypes: nodes.reduce((acc, node) => {\r\n      acc[node.type] = (acc[node.type] || 0) + 1;\r\n      return acc;\r\n    }, {})\r\n  };\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}