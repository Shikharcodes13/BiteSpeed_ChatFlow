{"ast":null,"code":"// Flow validation utility functions\n\n/**\r\n * Validates the flow before saving\r\n * @param {Array} nodes - Array of nodes in the flow\r\n * @param {Array} edges - Array of edges in the flow\r\n * @returns {Object} - Validation result with isValid boolean and error message\r\n */\nexport const validateFlow = (nodes, edges) => {\n  // If there are no nodes, the flow is valid (empty flow)\n  if (nodes.length === 0) {\n    return {\n      isValid: true,\n      error: ''\n    };\n  }\n\n  // If there's only one node, the flow is valid\n  if (nodes.length === 1) {\n    return {\n      isValid: true,\n      error: ''\n    };\n  }\n\n  // Check for nodes with empty target handles\n  const nodesWithEmptyTargetHandles = getNodesWithEmptyTargetHandles(nodes, edges);\n\n  // Validation rule: If there are more than one nodes and more than one node has empty target handles\n  if (nodes.length > 1 && nodesWithEmptyTargetHandles.length > 1) {\n    return {\n      isValid: false,\n      error: 'Cannot save Flow: More than one node has empty target handles. Please connect all nodes properly.'\n    };\n  }\n\n  // Additional validation: Check for disconnected nodes (nodes with no connections at all)\n  const disconnectedNodes = getDisconnectedNodes(nodes, edges);\n  if (disconnectedNodes.length > 0) {\n    return {\n      isValid: false,\n      error: `Cannot save Flow: Found ${disconnectedNodes.length} disconnected node(s). Please connect all nodes to create a valid flow.`\n    };\n  }\n  return {\n    isValid: true,\n    error: ''\n  };\n};\n\n/**\r\n * Gets nodes that have empty target handles (no incoming edges)\r\n * @param {Array} nodes - Array of nodes in the flow\r\n * @param {Array} edges - Array of edges in the flow\r\n * @returns {Array} - Array of node IDs with empty target handles\r\n */\nconst getNodesWithEmptyTargetHandles = (nodes, edges) => {\n  const nodesWithTargetHandles = nodes.filter(node => {\n    // Check if this node has any incoming edges (target handles)\n    const hasIncomingEdges = edges.some(edge => edge.target === node.id);\n    return !hasIncomingEdges;\n  });\n  return nodesWithTargetHandles.map(node => node.id);\n};\n\n/**\r\n * Gets nodes that are completely disconnected (no incoming or outgoing edges)\r\n * @param {Array} nodes - Array of nodes in the flow\r\n * @param {Array} edges - Array of edges in the flow\r\n * @returns {Array} - Array of node IDs that are disconnected\r\n */\nconst getDisconnectedNodes = (nodes, edges) => {\n  return nodes.filter(node => {\n    // Check if this node has any connections (incoming or outgoing)\n    const hasIncomingEdges = edges.some(edge => edge.target === node.id);\n    const hasOutgoingEdges = edges.some(edge => edge.source === node.id);\n    return !hasIncomingEdges && !hasOutgoingEdges;\n  }).map(node => node.id);\n};\n\n/**\r\n * Gets the flow statistics for debugging purposes\r\n * @param {Array} nodes - Array of nodes in the flow\r\n * @param {Array} edges - Array of edges in the flow\r\n * @returns {Object} - Flow statistics\r\n */\nexport const getFlowStats = (nodes, edges) => {\n  const nodesWithEmptyTargetHandles = getNodesWithEmptyTargetHandles(nodes, edges);\n  const disconnectedNodes = getDisconnectedNodes(nodes, edges);\n  return {\n    totalNodes: nodes.length,\n    totalEdges: edges.length,\n    nodesWithEmptyTargetHandles: nodesWithEmptyTargetHandles.length,\n    disconnectedNodes: disconnectedNodes.length,\n    nodeTypes: nodes.reduce((acc, node) => {\n      acc[node.type] = (acc[node.type] || 0) + 1;\n      return acc;\n    }, {})\n  };\n};","map":{"version":3,"names":["validateFlow","nodes","edges","length","isValid","error","nodesWithEmptyTargetHandles","getNodesWithEmptyTargetHandles","disconnectedNodes","getDisconnectedNodes","nodesWithTargetHandles","filter","node","hasIncomingEdges","some","edge","target","id","map","hasOutgoingEdges","source","getFlowStats","totalNodes","totalEdges","nodeTypes","reduce","acc","type"],"sources":["C:/Users/hp/BiteSpeed/src/utils/flowValidation.js"],"sourcesContent":["// Flow validation utility functions\r\n\r\n/**\r\n * Validates the flow before saving\r\n * @param {Array} nodes - Array of nodes in the flow\r\n * @param {Array} edges - Array of edges in the flow\r\n * @returns {Object} - Validation result with isValid boolean and error message\r\n */\r\nexport const validateFlow = (nodes, edges) => {\r\n  // If there are no nodes, the flow is valid (empty flow)\r\n  if (nodes.length === 0) {\r\n    return { isValid: true, error: '' };\r\n  }\r\n\r\n  // If there's only one node, the flow is valid\r\n  if (nodes.length === 1) {\r\n    return { isValid: true, error: '' };\r\n  }\r\n\r\n  // Check for nodes with empty target handles\r\n  const nodesWithEmptyTargetHandles = getNodesWithEmptyTargetHandles(nodes, edges);\r\n\r\n  // Validation rule: If there are more than one nodes and more than one node has empty target handles\r\n  if (nodes.length > 1 && nodesWithEmptyTargetHandles.length > 1) {\r\n    return {\r\n      isValid: false,\r\n      error: 'Cannot save Flow: More than one node has empty target handles. Please connect all nodes properly.'\r\n    };\r\n  }\r\n\r\n  // Additional validation: Check for disconnected nodes (nodes with no connections at all)\r\n  const disconnectedNodes = getDisconnectedNodes(nodes, edges);\r\n  if (disconnectedNodes.length > 0) {\r\n    return {\r\n      isValid: false,\r\n      error: `Cannot save Flow: Found ${disconnectedNodes.length} disconnected node(s). Please connect all nodes to create a valid flow.`\r\n    };\r\n  }\r\n\r\n  return { isValid: true, error: '' };\r\n};\r\n\r\n/**\r\n * Gets nodes that have empty target handles (no incoming edges)\r\n * @param {Array} nodes - Array of nodes in the flow\r\n * @param {Array} edges - Array of edges in the flow\r\n * @returns {Array} - Array of node IDs with empty target handles\r\n */\r\nconst getNodesWithEmptyTargetHandles = (nodes, edges) => {\r\n  const nodesWithTargetHandles = nodes.filter(node => {\r\n    // Check if this node has any incoming edges (target handles)\r\n    const hasIncomingEdges = edges.some(edge => edge.target === node.id);\r\n    return !hasIncomingEdges;\r\n  });\r\n\r\n  return nodesWithTargetHandles.map(node => node.id);\r\n};\r\n\r\n/**\r\n * Gets nodes that are completely disconnected (no incoming or outgoing edges)\r\n * @param {Array} nodes - Array of nodes in the flow\r\n * @param {Array} edges - Array of edges in the flow\r\n * @returns {Array} - Array of node IDs that are disconnected\r\n */\r\nconst getDisconnectedNodes = (nodes, edges) => {\r\n  return nodes.filter(node => {\r\n    // Check if this node has any connections (incoming or outgoing)\r\n    const hasIncomingEdges = edges.some(edge => edge.target === node.id);\r\n    const hasOutgoingEdges = edges.some(edge => edge.source === node.id);\r\n    \r\n    return !hasIncomingEdges && !hasOutgoingEdges;\r\n  }).map(node => node.id);\r\n};\r\n\r\n/**\r\n * Gets the flow statistics for debugging purposes\r\n * @param {Array} nodes - Array of nodes in the flow\r\n * @param {Array} edges - Array of edges in the flow\r\n * @returns {Object} - Flow statistics\r\n */\r\nexport const getFlowStats = (nodes, edges) => {\r\n  const nodesWithEmptyTargetHandles = getNodesWithEmptyTargetHandles(nodes, edges);\r\n  const disconnectedNodes = getDisconnectedNodes(nodes, edges);\r\n\r\n  return {\r\n    totalNodes: nodes.length,\r\n    totalEdges: edges.length,\r\n    nodesWithEmptyTargetHandles: nodesWithEmptyTargetHandles.length,\r\n    disconnectedNodes: disconnectedNodes.length,\r\n    nodeTypes: nodes.reduce((acc, node) => {\r\n      acc[node.type] = (acc[node.type] || 0) + 1;\r\n      return acc;\r\n    }, {})\r\n  };\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}